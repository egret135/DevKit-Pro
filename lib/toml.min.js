// Simple TOML Parser (basic implementation)
// Supports basic key-value pairs, sections, and common types

const TOML = (function () {
    'use strict';

    function parse(content) {
        const result = {};
        let currentSection = result;
        const lines = content.split('\n');

        for (let line of lines) {
            line = line.trim();

            // Skip empty lines and comments
            if (!line || line.startsWith('#')) continue;

            // Section header [section] or [[array]]
            if (line.startsWith('[')) {
                const isArray = line.startsWith('[[');
                const sectionMatch = isArray
                    ? line.match(/^\[\[([^\]]+)\]\]/)
                    : line.match(/^\[([^\]]+)\]/);

                if (sectionMatch) {
                    const sectionPath = sectionMatch[1].trim().split('.');
                    currentSection = result;

                    for (let i = 0; i < sectionPath.length; i++) {
                        const key = sectionPath[i];
                        if (i === sectionPath.length - 1 && isArray) {
                            if (!currentSection[key]) currentSection[key] = [];
                            const newObj = {};
                            currentSection[key].push(newObj);
                            currentSection = newObj;
                        } else {
                            if (!currentSection[key]) currentSection[key] = {};
                            currentSection = currentSection[key];
                        }
                    }
                }
                continue;
            }

            // Key-value pair
            const kvMatch = line.match(/^([^=]+)=(.*)$/);
            if (kvMatch) {
                const key = kvMatch[1].trim();
                let value = kvMatch[2].trim();
                currentSection[key] = parseValue(value);
            }
        }

        return result;
    }

    function parseValue(value) {
        // String (double or single quotes)
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
            return value.slice(1, -1)
                .replace(/\\n/g, '\n')
                .replace(/\\t/g, '\t')
                .replace(/\\"/g, '"')
                .replace(/\\\\/g, '\\');
        }

        // Boolean
        if (value === 'true') return true;
        if (value === 'false') return false;

        // Array
        if (value.startsWith('[') && value.endsWith(']')) {
            const inner = value.slice(1, -1).trim();
            if (!inner) return [];
            // Simple array parsing (doesn't handle nested arrays well)
            const items = [];
            let current = '';
            let inString = false;
            let stringChar = '';

            for (let i = 0; i < inner.length; i++) {
                const char = inner[i];
                if (inString) {
                    current += char;
                    if (char === stringChar && inner[i - 1] !== '\\') {
                        inString = false;
                    }
                } else if (char === '"' || char === "'") {
                    inString = true;
                    stringChar = char;
                    current += char;
                } else if (char === ',') {
                    if (current.trim()) items.push(parseValue(current.trim()));
                    current = '';
                } else {
                    current += char;
                }
            }
            if (current.trim()) items.push(parseValue(current.trim()));
            return items;
        }

        // Number (integer or float)
        if (/^-?\d+$/.test(value)) {
            return parseInt(value, 10);
        }
        if (/^-?\d*\.\d+$/.test(value)) {
            return parseFloat(value);
        }

        // Date/time (basic)
        if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
            const date = new Date(value);
            if (!isNaN(date.getTime())) return date;
        }

        // Return as string if nothing matches
        return value;
    }

    function stringify(obj, prefix = '') {
        let result = '';
        const tables = [];

        for (const [key, value] of Object.entries(obj)) {
            if (value === null || value === undefined) continue;

            if (typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {
                tables.push({ key: prefix ? `${prefix}.${key}` : key, value });
            } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                // Array of tables
                for (const item of value) {
                    const tableKey = prefix ? `${prefix}.${key}` : key;
                    result += `\n[[${tableKey}]]\n`;
                    result += stringify(item, '');
                }
            } else {
                result += `${key} = ${stringifyValue(value)}\n`;
            }
        }

        for (const table of tables) {
            result += `\n[${table.key}]\n`;
            result += stringify(table.value, '');
        }

        return result.trim();
    }

    function stringifyValue(value) {
        if (typeof value === 'string') {
            return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`;
        }
        if (typeof value === 'boolean') {
            return value ? 'true' : 'false';
        }
        if (typeof value === 'number') {
            return value.toString();
        }
        if (value instanceof Date) {
            return value.toISOString();
        }
        if (Array.isArray(value)) {
            return `[${value.map(stringifyValue).join(', ')}]`;
        }
        return JSON.stringify(value);
    }

    return { parse, stringify };
})();