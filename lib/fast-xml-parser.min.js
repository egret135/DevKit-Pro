// Simple XML Parser for browser
// Provides XMLParser class compatible with fast-xml-parser API

var fxParser = (function () {
    'use strict';

    class XMLParser {
        constructor(options = {}) {
            this.options = {
                ignoreAttributes: options.ignoreAttributes || false,
                attributeNamePrefix: options.attributeNamePrefix || '@_',
                textNodeName: options.textNodeName || '#text',
                ...options
            };
        }

        parse(xmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlString, 'text/xml');

            // Check for parse errors
            const parseError = doc.querySelector('parsererror');
            if (parseError) {
                throw new Error('XML Parse Error: ' + parseError.textContent);
            }

            return this._nodeToObject(doc.documentElement);
        }

        _nodeToObject(node) {
            const obj = {};

            // Handle attributes
            if (!this.options.ignoreAttributes && node.attributes && node.attributes.length > 0) {
                for (let i = 0; i < node.attributes.length; i++) {
                    const attr = node.attributes[i];
                    obj[this.options.attributeNamePrefix + attr.name] = attr.value;
                }
            }

            // Handle child nodes
            for (let i = 0; i < node.childNodes.length; i++) {
                const child = node.childNodes[i];

                if (child.nodeType === Node.TEXT_NODE) {
                    const text = child.textContent.trim();
                    if (text) {
                        if (Object.keys(obj).length === 0) {
                            return text;
                        }
                        obj[this.options.textNodeName] = text;
                    }
                } else if (child.nodeType === Node.ELEMENT_NODE) {
                    const childObj = this._nodeToObject(child);
                    const childName = child.nodeName;

                    if (obj[childName]) {
                        // Convert to array if multiple children with same name
                        if (!Array.isArray(obj[childName])) {
                            obj[childName] = [obj[childName]];
                        }
                        obj[childName].push(childObj);
                    } else {
                        obj[childName] = childObj;
                    }
                }
            }

            return obj;
        }
    }

    class XMLBuilder {
        constructor(options = {}) {
            this.options = {
                format: options.format !== false,
                indentBy: options.indentBy || '  ',
                attributeNamePrefix: options.attributeNamePrefix || '@_',
                textNodeName: options.textNodeName || '#text',
                ...options
            };
        }

        build(obj) {
            if (!obj || typeof obj !== 'object') {
                return '';
            }

            const keys = Object.keys(obj);
            if (keys.length === 0) {
                return '';
            }

            // Find the root element (first non-attribute key)
            const rootKey = keys.find(k => !k.startsWith(this.options.attributeNamePrefix));
            if (!rootKey) {
                return '';
            }

            return '<?xml version="1.0" encoding="UTF-8"?>\n' +
                this._buildNode(rootKey, obj[rootKey], 0);
        }

        _buildNode(name, value, depth) {
            const indent = this.options.format ? this.options.indentBy.repeat(depth) : '';
            const newline = this.options.format ? '\n' : '';

            if (value === null || value === undefined) {
                return `${indent}<${name}/>${newline}`;
            }

            if (typeof value !== 'object') {
                return `${indent}<${name}>${this._escapeXml(String(value))}</${name}>${newline}`;
            }

            if (Array.isArray(value)) {
                return value.map(item => this._buildNode(name, item, depth)).join('');
            }

            // Build attributes string
            let attrs = '';
            const childContent = [];

            for (const [key, val] of Object.entries(value)) {
                if (key.startsWith(this.options.attributeNamePrefix)) {
                    const attrName = key.slice(this.options.attributeNamePrefix.length);
                    attrs += ` ${attrName}="${this._escapeXml(String(val))}"`;
                } else if (key === this.options.textNodeName) {
                    childContent.push(this._escapeXml(String(val)));
                } else if (Array.isArray(val)) {
                    val.forEach(item => {
                        childContent.push(this._buildNode(key, item, depth + 1));
                    });
                } else {
                    childContent.push(this._buildNode(key, val, depth + 1));
                }
            }

            if (childContent.length === 0) {
                return `${indent}<${name}${attrs}/>${newline}`;
            }

            const hasChildElements = childContent.some(c => c.includes('<'));
            if (hasChildElements) {
                return `${indent}<${name}${attrs}>${newline}${childContent.join('')}${indent}</${name}>${newline}`;
            } else {
                return `${indent}<${name}${attrs}>${childContent.join('')}</${name}>${newline}`;
            }
        }

        _escapeXml(str) {
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
    }

    return {
        XMLParser,
        XMLBuilder
    };
})();